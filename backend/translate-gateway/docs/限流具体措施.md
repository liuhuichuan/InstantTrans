éå¸¸å¥½é—®é¢˜ ğŸ‘
ä½ ç°åœ¨ç”¨çš„æ˜¯ **Go + gorilla/websocket**ï¼Œé‚£æˆ‘æ¥å¸®ä½ **åˆ†æ¸…æ¥šä¼˜å…ˆçº§**â€”â€”ä¸æ˜¯æ‰€æœ‰æªæ–½éƒ½éœ€è¦ä¸€æ¬¡æ€§ä¸Šé½ï¼Œå¦åˆ™å·¥ç¨‹å¤æ‚åº¦ä¼šçˆ†ç‚¸ã€‚

---

## ğŸ§± ä¸€ã€æ ¸å¿ƒç›®æ ‡ï¼šé˜²æ­¢æœåŠ¡å™¨è¢«åˆ·çˆ†

æˆ‘ä»¬å¯ä»¥åˆ†æˆä¸‰ä¸ªå±‚æ¬¡æ¥è®¾è®¡ï¼š

| å±‚çº§        | ä¼˜å…ˆçº§  | ä½œç”¨          | æ˜¯å¦å»ºè®®ä¸€å¼€å§‹å°±ä¸Š |
| --------- | ---- | ----------- | --------- |
| **åŸºç¡€å®‰å…¨å±‚** | â­â­â­â­ | é˜²æ­¢æœ€ç›´æ¥çš„èµ„æºæ¶ˆè€—  | âœ… å¿…é¡»é›†æˆ    |
| **åè®®å®‰å…¨å±‚** | â­â­â­  | é˜²æ­¢ä¼ªé€ è¯·æ±‚å’Œæ»¥ç”¨   | âœ… å»ºè®®é›†æˆ    |
| **é˜²å¾¡å¢å¼ºå±‚** | â­â­   | ç›‘æ§ã€é»‘åå•ã€DDoS | ğŸš€ å¯åæœŸåŠ å…¥  |

---

## âœ… ä¸€å¼€å§‹å°±è¯¥åšçš„ï¼ˆå¿…é¡»ï¼‰

### 1ï¸âƒ£ è¿æ¥é¢‘ç‡é™åˆ¶ï¼ˆIPçº§ï¼‰

é˜²æ­¢ç¬é—´å¹¶å‘è¿æ¥æ‰“çˆ†æœåŠ¡ã€‚
å¯ä»¥åœ¨å†…å­˜ï¼ˆæˆ– Redisï¼‰ä¸­ç»´æŠ¤è®¡æ•°å™¨ï¼š

```go
type RateLimiter struct {
	mu sync.Mutex
	connections map[string]int
	lastReset   time.Time
}

func (r *RateLimiter) Allow(ip string) bool {
	r.mu.Lock()
	defer r.mu.Unlock()
	if time.Since(r.lastReset) > time.Minute {
		r.connections = make(map[string]int)
		r.lastReset = time.Now()
	}
	r.connections[ip]++
	return r.connections[ip] <= 5 // æ¯åˆ†é’Ÿæœ€å¤š 5 æ¬¡è¿æ¥
}
```

åœ¨ä½ çš„ `http.Handler` é‡Œï¼š

```go
ip := getClientIP(r)
if !rateLimiter.Allow(ip) {
	http.Error(w, "Too many connections", http.StatusTooManyRequests)
	return
}
```

---

### 2ï¸âƒ£ é‰´æƒ + token éªŒè¯

å®¢æˆ·ç«¯è¿æ¥æ—¶å¿…é¡»æºå¸¦æœ‰æ•ˆçš„ `token`ï¼ˆä¾‹å¦‚ JWT æˆ–çŸ­æœŸç­¾åï¼‰ã€‚

```go
func validateToken(r *http.Request) bool {
	token := r.URL.Query().Get("token")
	return checkJWT(token) // è‡ªè¡Œå®ç°
}
```

åœ¨æ¡æ‰‹å‰æ‹¦æˆªæ— æ•ˆ tokenï¼Œæ‹’ç»è¿æ¥ã€‚
â¡ï¸ é˜²æ­¢åŒ¿ååˆ·è¿æ¥ã€ä¼ªé€ è¿æ¥ã€‚

---

### 3ï¸âƒ£ å•è¿æ¥é™é€Ÿ

é˜²æ­¢æ¶æ„å®¢æˆ·ç«¯å»ºç«‹è¿æ¥åç–¯ç‹‚å‘æ¶ˆæ¯ã€‚

ç¤ºä¾‹ï¼š

```go
type Client struct {
	conn *websocket.Conn
	msgCount int
	lastReset time.Time
}

func (c *Client) ReadLoop() {
	for {
		_, msg, err := c.conn.ReadMessage()
		if err != nil {
			break
		}
		now := time.Now()
		if now.Sub(c.lastReset) > time.Second {
			c.lastReset = now
			c.msgCount = 0
		}
		c.msgCount++
		if c.msgCount > 10 { // æ¯ç§’æœ€å¤š10æ¡
			c.conn.WriteMessage(websocket.CloseMessage, []byte("Rate limit exceeded"))
			c.conn.Close()
			break
		}
	}
}
```

---

## ğŸŸ¡ ç¬¬äºŒé˜¶æ®µå»ºè®®åŠ çš„ï¼ˆåè®®å®‰å…¨å±‚ï¼‰

### 4ï¸âƒ£ ç­¾å + æ—¶é—´æˆ³

é¿å… token è¢«åˆ«äººé‡æ”¾ä½¿ç”¨ï¼š

```
/ws?uid=123&ts=1730690000&sign=sha256(uid+ts+secret)
```

æœåŠ¡ç«¯éªŒè¯ï¼š

* `ts` ä¸è¶…è¿‡ Â±60 ç§’ï¼›
* `sign` æ­£ç¡®ã€‚

---

### 5ï¸âƒ£ é™åˆ¶æ¶ˆæ¯ä½“å¤§å° + JSON éªŒè¯

* è¶…è¿‡ 2KB ç›´æ¥æ–­å¼€ï¼›
* æ— æ•ˆ JSON æ‹’ç»å¤„ç†ã€‚

```go
conn.SetReadLimit(2048)
```

---

### 6ï¸âƒ£ å¿ƒè·³ + è¶…æ—¶æ–­å¼€

æ²¡å“åº” pong å°±æ–­ï¼š

```go
conn.SetPongHandler(func(appData string) error {
	c.lastPong = time.Now()
	return nil
})
```

---

## ğŸ§  ç¬¬ä¸‰é˜¶æ®µï¼ˆå¢å¼ºå±‚ï¼Œå¯åæœŸä¸Šï¼‰

| åŠŸèƒ½                    | è¯´æ˜                                  |
| --------------------- | ----------------------------------- |
| é»‘åå•                   | Redis å­˜å‚¨è¢«å°ç¦ IP / token              |
| æ—¥å¿—å‘Šè­¦                  | å½“è§¦å‘é™æµäº‹ä»¶æ—¶ä¸ŠæŠ¥                          |
| Cloudflare / Nginx é™æµ | é˜²å¾¡ DDoS                             |
| Metrics               | prometheus + Grafana ç›‘æ§è¿æ¥æ•°ã€æ–­è¿æ•°ã€æ¶ˆæ¯é€Ÿç‡ |

---

## ğŸªœ æ¨èå®æ–½é¡ºåº

| é˜¶æ®µ              | è¦åšçš„äº‹                  |
| --------------- | --------------------- |
| **é˜¶æ®µ1ï¼šä¸Šçº¿æœ€å°å®‰å…¨é›†** | âœ… é™åˆ¶è¿æ¥é¢‘ç‡ + é‰´æƒ + å•è¿æ¥é™é€Ÿ |
| **é˜¶æ®µ2ï¼šå¢å¼ºå¯é æ€§**   | âœ… å¿ƒè·³æ£€æµ‹ + æ¶ˆæ¯å¤§å°é™åˆ¶       |
| **é˜¶æ®µ3ï¼šç”Ÿäº§é˜²æŠ¤**    | âœ… ç­¾å/æ—¶é—´æˆ³ã€ç›‘æ§ã€é»‘åå•       |

---

## ğŸ’¬ å°ç»“

> âœ… ä¸€å¥è¯æ€»ç»“ï¼š
> ä½ ä¸€å¼€å§‹ **å¿…é¡»é›†æˆé™æµ + é‰´æƒ + æ¶ˆæ¯é€Ÿç‡æ§åˆ¶**ï¼Œ
> è¿™æ˜¯æœ€ä½æˆæœ¬é˜²å¾¡ï¼Œä¹Ÿæ˜¯æœ€æœ‰æ•ˆçš„ã€‚

å‰©ä¸‹çš„ç­¾åéªŒè¯ã€é»‘åå•ã€æ—¥å¿—ç›‘æ§ç­‰å¯ä»¥ç­‰é¡¹ç›®ç¨³å®šåå†åŠ ã€‚

---

æˆ‘å¯ä»¥ç›´æ¥å¸®ä½ åŸºäº gorilla/websocket å†™ä¸€ä¸ª **æ•´åˆé™æµ + é‰´æƒ + æ¶ˆæ¯é€Ÿç‡é™åˆ¶çš„æ¨¡æ¿ server.go**ï¼Œä½ åªéœ€æ‹·è´å³å¯ä½¿ç”¨ã€‚
è¦æˆ‘å¸®ä½ ç”Ÿæˆå—ï¼Ÿ
